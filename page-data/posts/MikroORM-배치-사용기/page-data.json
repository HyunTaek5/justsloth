{"componentChunkName":"component---src-template-post-tsx","path":"/posts/MikroORM-배치-사용기","result":{"data":{"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/posts/MikroORM-배치-사용기/"},"timeToRead":2,"frontmatter":{"title":"MikroORM 배치 사용기","series":"MikroORM 사용기"}},{"fields":{"slug":"/posts/book/review/오픈-비즈니스패권의-열쇠/"},"timeToRead":1,"frontmatter":{"title":"오픈 비즈니스 패권의 열쇠","series":"책 리뷰"}},{"fields":{"slug":"/posts/book/review/비전공자도-배울-수-있는-타입스크립트/"},"timeToRead":1,"frontmatter":{"title":"비전공자도 배울 수 있는 타입스크립트","series":"책 리뷰"}},{"fields":{"slug":"/posts/book/review/테라폼으로-시작하는-IaC/"},"timeToRead":1,"frontmatter":{"title":"테라폼으로 시작하는 IaC","series":"책 리뷰"}},{"fields":{"slug":"/posts/book/review/코드-밖-커뮤니케이션/"},"timeToRead":1,"frontmatter":{"title":"코드 밖 커뮤니케이션","series":"책 리뷰"}},{"fields":{"slug":"/posts/book/review/NGINX-쿡북/"},"timeToRead":1,"frontmatter":{"title":"NGINX 쿡북","series":"책 리뷰"}},{"fields":{"slug":"/posts/book/review/처음-시작하는-FastAPI/"},"timeToRead":1,"frontmatter":{"title":"처음 시작하는 FastAPI","series":"책 리뷰"}},{"fields":{"slug":"/posts/book/review/업무에-활용하는-nodejs/"},"timeToRead":1,"frontmatter":{"title":"업무에 활용하는 Node.js","series":"책 리뷰"}},{"fields":{"slug":"/posts/book/review/한권으로-배우는-도커&쿠버네티스/"},"timeToRead":1,"frontmatter":{"title":"한 권으로 배우는 도커 & 쿠버네티스","series":"책 리뷰"}},{"fields":{"slug":"/posts/book/review/도시를-만드는-기술-이야기/"},"timeToRead":1,"frontmatter":{"title":"도시를 만드는 기술 이야기","series":"책 리뷰"}},{"fields":{"slug":"/posts/book/가상-면접-사례-솔루션/1장/"},"timeToRead":1,"frontmatter":{"title":"사용자 수에 따른 규모 확장성","series":"가상 면접 사례로 배우는 대규모 시스템 설계 기초"}},{"fields":{"slug":"/posts/book/review/게임AI를-위한-탐색-알고리즘/"},"timeToRead":1,"frontmatter":{"title":"게임 AI를 위한 탐색 알고리즘","series":"책 리뷰"}},{"fields":{"slug":"/posts/블로그-이관/"},"timeToRead":1,"frontmatter":{"title":"블로그 이관","series":null}},{"fields":{"slug":"/posts/블로그-글-시작하기/"},"timeToRead":1,"frontmatter":{"title":"기술 블로그 글 시작하기","series":"글 잘 쓰기"}},{"fields":{"slug":"/posts/TIL/2023/2023-12/프로젝트-회고/"},"timeToRead":1,"frontmatter":{"title":"2023 사내 프로젝트 회고","series":"배포 회고"}},{"fields":{"slug":"/posts/TIL/2023/2023-12/나무늘보-프롬프트/"},"timeToRead":1,"frontmatter":{"title":"GPT-4 나무늘보 프롬프트","series":"프롬프트"}},{"fields":{"slug":"/posts/TIL/2023/2023-12/채팅-리서치/"},"timeToRead":1,"frontmatter":{"title":"채팅 구현 관련 서비스 리서치","series":"리서치 기록"}},{"fields":{"slug":"/posts/TIL/2023/2023-12/NestJs/Request-LifeCycle/"},"timeToRead":1,"frontmatter":{"title":"NestJs - Request LifeCycle","series":"NestJs"}},{"fields":{"slug":"/posts/TIL/2023/2023-12/NestJs/LifeCycle/"},"timeToRead":1,"frontmatter":{"title":"NestJs - LifeCycle","series":"NestJs"}},{"fields":{"slug":"/posts/TIL/2023/2023-12/DirtyChecking/"},"timeToRead":1,"frontmatter":{"title":"더티 체킹","series":null}},{"fields":{"slug":"/posts/TIL/2023/2023-11/NestJs/Pipes/"},"timeToRead":1,"frontmatter":{"title":"NestJs - Pipes","series":"NestJs 개념 정리"}},{"fields":{"slug":"/posts/TIL/2023/2023-11/Nginx/"},"timeToRead":1,"frontmatter":{"title":"Docker-compose, Nginx와 함께하는 무중단 배포","series":"배포 회고"}},{"fields":{"slug":"/posts/TIL/2023/2023-11/NestJs/MetaData/"},"timeToRead":1,"frontmatter":{"title":"NestJs - MetaData","series":"NestJs 개념 정리"}},{"fields":{"slug":"/posts/TIL/2023/2023-11/AWS - EBS용량관리/"},"timeToRead":1,"frontmatter":{"title":"AWS - EBS 용량 관리","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-11/NestJs/DynamicModule/"},"timeToRead":1,"frontmatter":{"title":"NestJs - Dynamic Module","series":"NestJs 개념 정리"}},{"fields":{"slug":"/posts/TIL/2023/2023-10/OpenTelemetry/메트릭/"},"timeToRead":1,"frontmatter":{"title":"OpenTelemetry  - 메트릭","series":"TIL"}},{"fields":{"slug":"/posts/사이드프로젝트-배포-회고/"},"timeToRead":2,"frontmatter":{"title":"사이드 프로젝트 배포 회고","series":"배포 회고"}},{"fields":{"slug":"/posts/TIL/2023/2023-10/OpenTelemetry/시그널-분산추적/"},"timeToRead":1,"frontmatter":{"title":"OpenTelemetry 시그널 - 분산 추적","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-10/OpenTelemetry/컨텍스트-전파/"},"timeToRead":1,"frontmatter":{"title":"OpenTelemetry - 컨텍스트 전파","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-10/OpenTelemetry/파이프라인-리소스/"},"timeToRead":1,"frontmatter":{"title":"OpenTelemetry - 파이프라인, 리소스","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-10/OpenTelemetry/"},"timeToRead":1,"frontmatter":{"title":"OpenTelemetry","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-10/제3자-결제-애플/"},"timeToRead":3,"frontmatter":{"title":"관찰 가능성 엔지니어링 & 제 3자 결제 - 애플","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-10/제3자-결제-구글/"},"timeToRead":1,"frontmatter":{"title":"제 3자 결제 - 구글","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-10/PortOne-웹훅/"},"timeToRead":1,"frontmatter":{"title":"PortOne - 웹훅","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-10/PortOne-인증결제/"},"timeToRead":1,"frontmatter":{"title":"PortOne - 인증결제","series":"TIL"}},{"fields":{"slug":"/posts/book/대용량-DB-솔루션/1장/"},"timeToRead":1,"frontmatter":{"title":"대용량 DB 솔루션 1장 정리","series":"대용량 DB 솔루션"}},{"fields":{"slug":"/posts/TIL/2023/2023-09/PortOne/"},"timeToRead":1,"frontmatter":{"title":"PortOne - 비인증결제 정리","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-09/인앱-결제/환불/"},"timeToRead":1,"frontmatter":{"title":"인앱 결제 환불 정리","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-09/인앱-결제/"},"timeToRead":1,"frontmatter":{"title":"인앱 결제 정리","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-09/SRE/"},"timeToRead":1,"frontmatter":{"title":"SRE (Site Reliability Engineering) 개념","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-09/SQL-INTERSECT/"},"timeToRead":1,"frontmatter":{"title":"SQL - INTERSECT","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-09/SQL-UNION-ALL/"},"timeToRead":1,"frontmatter":{"title":"SQL - UNION / UNION ALL","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-09/MongoDB-local-참가-후기/"},"timeToRead":1,"frontmatter":{"title":"MongoDB.local Seoul 짧은 참가 후기","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-09/OLTP VS OLAP/"},"timeToRead":1,"frontmatter":{"title":"OLTP vs OLAP","series":"TIL"}},{"fields":{"slug":"/posts/TIL/2023/2023-09/TypeORM-Upsert-중복제거/"},"timeToRead":1,"frontmatter":{"title":"TypeORM orIgnore 메소드 Upsert시 중복 데이터 INSERT 검증 방식 변경","series":"TIL"}}],"group":[{"fieldValue":"MikroORM 사용기","totalCount":1},{"fieldValue":"NestJs","totalCount":2},{"fieldValue":"NestJs 개념 정리","totalCount":3},{"fieldValue":"TIL","totalCount":19},{"fieldValue":"가상 면접 사례로 배우는 대규모 시스템 설계 기초","totalCount":1},{"fieldValue":"글 잘 쓰기","totalCount":1},{"fieldValue":"대용량 DB 솔루션","totalCount":1},{"fieldValue":"리서치 기록","totalCount":1},{"fieldValue":"배포 회고","totalCount":3},{"fieldValue":"책 리뷰","totalCount":10},{"fieldValue":"프롬프트","totalCount":1}]},"markdownRemark":{"id":"4a28581a-1f4b-510a-9f69-ab59bba89c7e","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.890625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZUlEQVR42q2SP0tCURjGzzl2byr5/14NlBoyyPB6EeQONegg/qNFh0TdzakcHNpClOKuQZtfoKXP0GBTW0M49AWCliiKpqfDxRtXCrmkw4/z8g7P+5z3fQghBEtmtkEtL11EkFJqYNYOs17EocAY4h4PtjiXmob9cNjoM8sg24I7Ph+us1m81Ot4qtXw1mjgTFEQEsU5TumUPwRvcjl8tlp45UIfzSYeqlXccUb5PJjTCSkUQiAYRDQiQ5YlkFUXmIEbxOrcnBx1u7HucqEQi2FSqeB9OATGY0xGI1wMBjjpdqHrOg6PT1E66kHMFODdO8CaVgIVxFmH5m6Sfj92OVd8f8/tNr76fYw7HSipFFRVhZpS4NxMQIxuYyUYgRDegCDHQJljVtBcuiZJuC0WcZ5O475cxiMnEwj8ipPtK9Op2wQ/UC+ZRNzr/bky4wkwfmJCrPUcQTM+bBk5tMLs586e4H/5BjXnOdwTIV0xAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"이미지1\"\n        title=\"\"\n        src=\"/static/5be349ec6296a8f1266212ec7d89fb6f/2bef9/1.png\"\n        srcset=\"/static/5be349ec6296a8f1266212ec7d89fb6f/6f3f2/1.png 256w,\n/static/5be349ec6296a8f1266212ec7d89fb6f/01e7c/1.png 512w,\n/static/5be349ec6296a8f1266212ec7d89fb6f/2bef9/1.png 1024w,\n/static/5be349ec6296a8f1266212ec7d89fb6f/c1b63/1.png 1200w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h1>MikroORM + Nest 배치 구현 log</h1>\n<h2>개요</h2>\n<p>Nest.js와 MikroORM으로 Batch 애플리케이션을 구현하면서 겪은 이슈에 대해 정리했다.</p>\n<p>기존 프로젝트 서버는 단일 애플리케이션으로 구성되어있어 api와 batch가 같은 서버, 같은 애플리케이션내에서 아래와 같은 구조로 동작하고 있었다.\nNest Server가 단일 프로세스로 PM2를 통해 관리되고 있었고, MySQL과 Redis는 docker 컨테이너로 구성되어 있었다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.890625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACUklEQVR42o1Uy4oTQRTNj/hl/olu3QyDgh+QhYjiSmQY0M2AEiMODIJZTKSNPZ3HpN9Jv9/dxzpFOqZJZ7DgdtetvnXqnFv39iCOYwRBgDAMey2OYlieJY3zU3G+7yNJEgwIdmo0TSPfl4tLnP08w0OjrmtEUYQB0cuy7LWqrJDmKUarES7+XMCObDRVg6IsjmLzPAfVSkDTNGFZ1klzbAeu7cLQDembhg5T1+W+dq8u/D3Drk5hVU0NneUsz+A4zoOS9wz/Z1CSLZhw6G9fQT1/hrVhYDKZSIYcXYa7C2hE3rzhB4Tvrzrrh4Da6yF+vzyH7fmYqXcIxcXyArsMdxs5ghdvYD1+esSwldyG5iI1epSjEH7TJ5mLfhTCWd7D+DVDKCR0JNu2nI+VBT7fqrC1G1jKFyRZ3sNwV3exACGQFwayUPsAC8FsE2fIMvG9ZEzdvRQmkw4tTVOkAihLUjnnGoHZCSyRWMwTsVaJWqzrCnnG+kvQ4shOcV0Xm82mY9vttjMnu/V6DVf4oe/heqpgeDXC7Xwlv8vDyLBtvTbRiVPh/m4Lw1wLSfmR5Pbqnnz6hkfP32Gs6dJPs0wqkpIpSUqlxCCGvw3kqZTAtUwEUzIZEtgPfHy9+YGP4+9QNQ1lUfz7ORCQhcnTpTk2XFEeZE5joOd5+xy1vsWWEy2oi+JmObH1ejul/cOQjSZOn8/nMng6nUJRFOmvVisUgtVhPJnvJfcBGuLk5XIpQWmz2QyLxQKqqkqfm3sB+WjlHBrzxqDWyOjwTXltLOdMBff8BQMvYVJXSv3KAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"legacy-arch1\"\n        title=\"\"\n        src=\"/static/b3f463c1bf6554e9fd93bebf96f6ae2b/2bef9/legacy-arch.png\"\n        srcset=\"/static/b3f463c1bf6554e9fd93bebf96f6ae2b/6f3f2/legacy-arch.png 256w,\n/static/b3f463c1bf6554e9fd93bebf96f6ae2b/01e7c/legacy-arch.png 512w,\n/static/b3f463c1bf6554e9fd93bebf96f6ae2b/2bef9/legacy-arch.png 1024w,\n/static/b3f463c1bf6554e9fd93bebf96f6ae2b/ee3fb/legacy-arch.png 1144w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위와 같은 구조로 서비스를 운영하다 아래와 같은 문제점들에 부딪히게 되었다.</p>\n<h2>문제점</h2>\n<ol>\n<li>Nest Server <strong>Scale Out 불가</strong></li>\n<li>불편한 Server Log Tracking</li>\n</ol>\n<h3>1. Nest Server Scale Out 불가</h3>\n<p>개요에서 상기한 것처럼 Nest Server는 단일 프로세스로 api와 batch 모두 단일 서버 애플리케이션에서 PM2를 통해 관리되고 있었다.\n이로 인해 batch와 api를 따로 배포할 수 없어 Nest Server의 Scale Out이 불가능했다.</p>\n<p>특정 주기마다 외부에서 데이터를 조회해와서 처리하는 batch들이 존재했는데 batch들이 동작하는 주기마다 간헐적으로 api 응답이 2~3초씩 지연되는 이슈가 발생하였다.\nbatch를 별도의 서버에 배포하고, 온프레미스 환경에서는 api만 운용하려는 방식을 고려하였지만, 하나의 Nest 애플리케이션에 api와 batch가 통합되어있어 바로 조치하기가 불가능하였다.</p>\n<h3>2. 불편한 Server Log Tracking</h3>\n<p>api 서버의 경우, http-logger라는 로깅 미들웨어를 통해 모든 HTTP api 요청에 대한 로그를 남기고 있었다. api 요청 처리시에 tracking 로그를 비롯한\n에러 exception 로그를 남기고 있었는데, batch가 동작시 api 요청 처리 로그 중간중간에 batch 진행 로그가 섞여 batch 진행 상황 및 api 에러 로그를 추적하기에\n애로 사항이 있었다.</p>\n<h2>해결 방안</h2>\n<p>단일 Nest 애플리케이션에서 api와 batch을 별개의 애플리케이션으로 분리하여 특정 애플리케이션에 리소스가 더 필요한 상황시 Scale Out이 가능하고,\n각 서버의 로그를 분리하여 관리할 수 있도록 구조를 변경하였다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACFklEQVR42nVTy47TQBDM7/JN3IATlz1ECysusAeEFpCAQ5YQZXEIUuLYsT1Pjx+xi+oJXlgJWurMeKa7p7qqMwshoGkatG0bXfbogUW+wFZtMfYjmvbPfV3X6HsG/MdmEtB1XQwS7/oOGID59zlu0htgBDoWjPen0/3j4zhiGIYHLmcz5xyUUjDGQGsNQ1daQRmNLM+geV4PI7z30auqguS0TQvpzljLfYOGe1lnciiV/2WKxTp6Nr9AmR1Q8WFBaFlETFALiMmaqeDwmxP/4i3ss8vzLR/RTGyItriaY5dmOBQVUQQ48ccXsNcf4Rlav2Te00u0wqFUHdm/mPl6B/Xm/f2LmohCf8LKtcjTNWpXkL8O2jvYd1+gPt1C9y3ct4R5HxjbnUWZBDG1hyHiniIJDcJXQ66cr9kFqelF5YA8y6BCjVJ4TlMoZ6GYK1TM5EdEkdVZB0/CRSD5zpjouW7Y7uvlHSptUBZF5LKmQNbYyKHkOO49kZ9bFlHYdZV5HJkwiVQSodir2zUePb9CIPLAjjxdzJUtjnkVx0ksiCiCpCzLiFJalDWOD1HKt+z3+z22m01EVxxz+PJAsQo0toTdJ3A/FgiK/Fr1cGxk3e12WK/XSJIEy+USq9UqPjhZIF/oPAoW/7lL4ZLPKK6fnPODORec/n7iIpIMrvuLSxnoOsZQIGsw+hIDk4daE1UJnadA62LBXzuwl3DTdMn2AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"current-arch1\"\n        title=\"\"\n        src=\"/static/6f896eee6248b7a7dbe0369f86970779/2bef9/current-arch.png\"\n        srcset=\"/static/6f896eee6248b7a7dbe0369f86970779/6f3f2/current-arch.png 256w,\n/static/6f896eee6248b7a7dbe0369f86970779/01e7c/current-arch.png 512w,\n/static/6f896eee6248b7a7dbe0369f86970779/2bef9/current-arch.png 1024w,\n/static/6f896eee6248b7a7dbe0369f86970779/71c1d/current-arch.png 1536w,\n/static/6f896eee6248b7a7dbe0369f86970779/76a18/current-arch.png 1691w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n해당 글을 Nest api와 batch를 별개의 애플리케이션으로 분리 구현하는 과정에서 생긴 Nest와 MikroORM의 이슈에 대해 정리하였다.</p>\n<h2>Batch 애플리케이션 구현시 MikroORM 관련 global EntityManager 이슈</h2>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"typescript\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">@</span><span class=\"mtk11\">Injectable</span><span class=\"mtk1\">()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">export</span><span class=\"mtk1\"> </span><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">ExampleBatch</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">constructor</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">private</span><span class=\"mtk1\"> </span><span class=\"mtk4\">readonly</span><span class=\"mtk1\"> </span><span class=\"mtk12\">orm</span><span class=\"mtk1\">: </span><span class=\"mtk10\">MikroORM</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">private</span><span class=\"mtk1\"> </span><span class=\"mtk4\">readonly</span><span class=\"mtk1\"> </span><span class=\"mtk12\">getExampleService</span><span class=\"mtk1\">: </span><span class=\"mtk10\">GetExampleService</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  ) {}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">async</span><span class=\"mtk1\"> </span><span class=\"mtk11\">main</span><span class=\"mtk1\">(): </span><span class=\"mtk10\">Promise</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">void</span><span class=\"mtk1\">&gt; {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// 배치 로직</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>위와 같은 형식으로 각각의 배치들을 구현하고 동작시키면,</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"shell\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">`ValidationError: Using global EntityManager instance methods </span><span class=\"mtk15\">for</span><span class=\"mtk8\"> context specific actions is disallowed.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">If you need to work with the global instance&#39;s identity map, use `allowGlobalContext` configuration option or `fork()` instead` </span></span></span></code></pre>\n<p>라는 에러 로그와 함께 배치 애플리케이션이 실행되지않고 바로 종료되는 이슈가 발생하였다.</p>\n<p>에러 로그를 살펴보면, global EntityManager 인스턴스 메소드를 사용하여 컨텍스트별 작업을 수행하려고 하여 발생하는 에러임을 알 수 있다.</p>\n<p>해당 에러를 이해하려면 MikroORM의 EntityManager와 Identity Map에 대해 알아봐야한다. MikroORM에서 context는 RequestContext를 의미하는데\n하나의 요청이 들어올 때, 해당 요청에 대한 RequestContext가 생성되고, 이 RequestContext에 대한 EntityManager가 생성된다. 각각의 EntityManager는\n1대1로 매칭되는 Identity Map을 가지고 있어, 같은 EntityManager로 조회한 Entity는 같은 Identity Map에 저장된다.</p>\n<p>하지만 배치 애플리케이션의 경우, 별도의 요청이 없이 주기적으로 동작하는 애플리케이션이기 때문에 RequestContext가 생성되지 않아 EntityManager가 생성되지 않는다.\n따라서, global EntityManager를 사용하여 요청 컨텍스트별 작업을 수행하려고 하면 EntityManager 생성에서 valid 에러가 발생하게 된다.\n만약 MikroORM v5 이전의 버전을 도입하였다면 해당 valid 에러가 발생하지 않지만, v5부터는 global identity map의 사용이 불가능해졌기 때문에\n해당 에러가 발생하게 된다. 만약 global identity map을 사용하려면 <code>allowGlobalContext</code> 옵션을 사용하거나 <code>fork()</code> 메소드를 사용하여\n새로운 EntityManager를 직접 생성해야한다.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"typescript\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">@</span><span class=\"mtk11\">Injectable</span><span class=\"mtk1\">()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">export</span><span class=\"mtk1\"> </span><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">ExampleBatch</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">constructor</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">private</span><span class=\"mtk1\"> </span><span class=\"mtk4\">readonly</span><span class=\"mtk1\"> </span><span class=\"mtk12\">orm</span><span class=\"mtk1\">: </span><span class=\"mtk10\">MikroORM</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">private</span><span class=\"mtk1\"> </span><span class=\"mtk4\">readonly</span><span class=\"mtk1\"> </span><span class=\"mtk12\">getExampleService</span><span class=\"mtk1\">: </span><span class=\"mtk10\">GetExampleService</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  ) {}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">async</span><span class=\"mtk1\"> </span><span class=\"mtk11\">main</span><span class=\"mtk1\">(): </span><span class=\"mtk10\">Promise</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">void</span><span class=\"mtk1\">&gt; {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// orm.em.fork()를 통해 새로운 EntityManager 생성</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> </span><span class=\"mtk12\">em</span><span class=\"mtk1\"> = </span><span class=\"mtk4\">this</span><span class=\"mtk1\">.</span><span class=\"mtk12\">orm</span><span class=\"mtk1\">.</span><span class=\"mtk12\">em</span><span class=\"mtk1\">.</span><span class=\"mtk11\">fork</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// 배치 로직</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>MikroORM에서 v5부터 global Identity Map혹은 EntityManager의 사용을 불가능하게 한 이유를 간단히 알아보자면, RequestContext 없이 global\nEntityManager의 남용으로 이상한 버그를 유발하고, 결과적으로 각 요청별 전용 Context를 두어야 간섭하지 않기 때문이다. 예를 들면 A라는 요청과 B 라는 요청\n을 모두 global EntityManager에서 처리시, A 요청의 처리를 위해 조회한 Entity 정보를 B 요청에서 참조할 수 있게 되는 등 예기치 못한 변수가 발생할 수 있다.\n이러한 상황을 막기위해 global EntityManager의 사용을 불가능하게 한 것이다.</p>\n<h2>결론</h2>\n<p>Nest.js와 MikroORM으로 Batch 애플리케이션을 구현하면서 겪은 이슈에 대해 정리하였다.\nMikroORM의 global EntityManager 사용에 대한 이슈를 해결하기 위해 <code>fork()</code> 메소드를 사용하여 새로운 EntityManager를 생성하여 사용하였다.\nMikroORM이 JPA와 매우 유사한 원리로 ORM을 제공하고 있어, JPA를 이해하고 있는 개발자라면 쉽게 사용할 수 있을 것이다.</p>\n<pre><code></code></pre>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .mtk1 { color: #D4D4D4; }\n  .dark-default-dark .mtk11 { color: #DCDCAA; }\n  .dark-default-dark .mtk15 { color: #C586C0; }\n  .dark-default-dark .mtk4 { color: #569CD6; }\n  .dark-default-dark .mtk10 { color: #4EC9B0; }\n  .dark-default-dark .mtk12 { color: #9CDCFE; }\n  .dark-default-dark .mtk3 { color: #6A9955; }\n  .dark-default-dark .mtk8 { color: #CE9178; }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","fields":{"slug":"/posts/MikroORM-배치-사용기/"},"timeToRead":2,"frontmatter":{"title":"MikroORM 배치 사용기","tags":["MikroORM","NestJS","배치"],"date":"2025-03-10T15:23:12.000Z","image":null,"series":"MikroORM 사용기"}}},"pageContext":{"id":"4a28581a-1f4b-510a-9f69-ab59bba89c7e"}},"staticQueryHashes":["3810308631","4253518612"],"slicesMap":{}}